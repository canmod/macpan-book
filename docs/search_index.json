[["index.html", "Generalized McMasterPandemic Chapter 1 Fast and Flexible Modelling with McMasterPandemic 1.1 Generalized Model at a Glance", " Generalized McMasterPandemic Steve Walker 2022-04-26 Chapter 1 Fast and Flexible Modelling with McMasterPandemic McMasterPandemic is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This book describes how to use this refactored version of McMasterPandemic. The general model underlying McMasterPandmic’s flexible engine and interface based on a discrete time compartmental model. remotes::install_github(&quot;mac-theobio/McMasterPandemic@tmb-condense&quot;) 1.1 Generalized Model at a Glance \\[ s_{i,t+1} = s_{i,t} + \\sum_j M_{ji,t} s_{j,t} - s_{i,t} \\sum_j M_{ij,t} \\delta_{ij} \\] where, \\(s_{i,t}\\) is the state of the \\(i\\)th compartment at time \\(t\\) \\(M_{ij,t}\\) is the per-capita rate of flow from compartment \\(i\\) to compartment \\(j\\) at time \\(t\\) \\(\\delta_{ij}\\) indicates whether or not individuals should be removed from compartment \\(i\\) after flowing to compartment \\(j\\) The per-capita rates, \\(M_{ij,t}\\), can be any expression involving only sums and products of any of the following at time \\(t\\): State of any compartment Model parameter – either time-varying or not Complements of any of the above (i.e. \\(1-x\\)) Inverses of any of the above (i.e. \\(1/x\\)) "],["simple-model-initializtion.html", "Chapter 2 Simple Model Initializtion 2.1 Initial Parameter Vector 2.2 Initial State Vector 2.3 Start and End Date 2.4 Next Steps", " Chapter 2 Simple Model Initializtion Before one may define the dynamics of their compartmental model they must initialize it using the init_model function. Here we describe each of the basic and required arguments to init_model and how to set them. This function allows one to define things like the parameter and state spaces, the date range in which to run simulations, default parameter values, and the initial state (or settings for computing stable initial states). However, in this chapter we just cover the basic requirements. Parameter vector State vector Start and end dates Here is a simple SIR model example. sir = flexmodel( params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) To learn more about these options, please keep reading this chapter. To continue building this simple SIR model, please move on the the next chapter, where you can define Flow Between States. 2.1 Initial Parameter Vector The parameter vector contains the following kinds of information. State transition rates or parameters determining them (e.g. transmission rate, \\(\\beta\\)) Initial numbers of individuals in a compartment or group of compartments (e.g. initial number of exposed individuals, \\(E_0\\)) Data processing parameters to make observed and simulated time-series more comparable (e.g. fraction of incidence reported as positive tests, \\(c_\\text{prop}\\)) In its simplest form these parameters can be specified as a standard named numeric vector. We used this approach above in our SIR example, and this parameter vector can be extracted from the model. sir$params ## beta gamma N ## 1e-01 1e-02 1e+02 McMasterPandemic also has a special params_pansim object class for representing parameters. These objects come with descriptions of the meaning of each parameter. An example of this params_pansim format can be explored with the following command. rmarkdown::paged_table(describe_params(read_params(&#39;ICU1.csv&#39;))) See the McMasterPandemic getting started vignette for more info on params_pansim objects. 2.2 Initial State Vector The state vector is used to declare the names of the state variables. In the SIR example above we did this via a named numeric vector, and these names become the names of the states. sir$state ## S I R ## 99 1 0 The numbers in this vector can be used as initial values in simulations, but often the initial values will depend on the parameters (see do_make_state TODO). In these cases where the initial state is computed as opposed to specified, the state argument to init_model can just be character vector giving the names of the state variables. Classic McMasterPandemic also has a state_pansim object type (TODO: describe). 2.3 Start and End Date The simulation model takes a step every day. The start_date and end_date arguments give start and end of these simulations. The format of these dates can be supplied in any format that is accepted by as.Date without any formatting options. 2.4 Next Steps Models can be initialized with more complex features including time-varying parameters, hazard steps, and model linearization for computing state vectors that lead to greater stability (TODO: link to chapters/sections). But before getting to these complexities there is something more important: definition of the flows of individuals amongst the states (TODO: link to next chapter). "],["flow-between-states.html", "Chapter 3 Flow Between States 3.1 State Flows 3.2 Flow Matrix 3.3 Rate Matrix 3.4 Rate Matrix Dependence on State Variables and Parameters 3.5 Next Steps", " Chapter 3 Flow Between States Here we describe the definition of the basic model of flows among states. Later chapters describe extensions to this basic model, both implemented (TODO) and unimplemented (TODO). The per-capita rate of flow between any two states can be defined using the add_rate function. sir = (sir %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) The first add_rate function says that on each simulated day, individuals flow from the S box to the I box at a rate equal to the product of I, beta, and 1/N. This rate is a per-capita rate, and so the flow of individuals from S to I is S times the rate. Similarly, the second add_rate function says that I times gamma individuals flow from I to R every simulated day. Here are the rules of these rate formulas (although these can be relaxed to some degree using techniques covered in later chapters). both state variables and parameters can be referred to by name as variables in the formulas variables must be encapsulated with parentheses variables can be converted to their inverse (1/x) or complement (1-x) varaibles, their inverses, and their complements can be combined using + and * operators Examples of valid rate formulas for this model include: (1-gamma) * (S) + (gamma) (1/I) (beta) * (gamma) + (beta) * (1/N) * (1-gamma) Examples of invalid rate formulas include: 1-gamma – no parentheses around this complement beta * gamma – no parentheses around variables (but this can be addressed using struc objects – TODO: link to these) ((S) + (R)) * (beta) – general grouping parentheses and common factors are not allowed (but this can be addressed using struc objects or intermediate computations – TODO: link to these) (E) * (beta) – the variable E is in neither the parameter nor state variable The remainder of this chapter describes the theory behind these rates, and clarifies what they mean. To start using this simple SIR model, please move on the the next chapter where you will learn how to do Simulation and explore epidemic trajectories. 3.1 State Flows The numbers of individuals in each compartment is stored in the state vector, \\(\\mathbf{s}\\), which contains one element for each compartment. At each time step, \\(t\\), the state vector is given by \\(\\mathbf{s}(t)\\). The relationship between the state vector at successive time steps is given by the following. \\[ \\mathbf{s}(t+1) = \\mathbf{s}(t) + \\mathbf{f}^{\\text{in}}(t) - \\mathbf{f}^{\\text{out}}(t) \\] where \\(\\mathbf{f}^{\\text{in}}\\) and \\(\\mathbf{f}^{\\text{out}}\\) are the inflow and outflow vectors. Continuing our concrete SIR model example, individuals flow from a box of susceptible individuals to infected to recovered individuals. \\[ S(t+1) = S(t) - \\frac{\\beta I(t)}{N}S(t) \\] \\[ I(t+1) = I(t) + \\frac{\\beta I(t)}{N}S(t) - \\gamma I(t) \\] \\[ R(t+1) = R(t) + \\gamma I(t) \\] where \\(\\beta\\), \\(\\gamma\\), and \\(N\\) are the transmission rate and population size parameters. In this model the inflow to the \\(S\\) box is zero and the outflow from \\(R\\) is also zero. Therefore we can express this model in general terms as the following. \\[ \\mathbf{s} = \\begin{bmatrix} S \\\\ I \\\\ R \\end{bmatrix} \\] \\[ \\mathbf{f}^{\\text{in}} = \\begin{bmatrix} 0 \\\\ \\frac{\\beta I S}{N} \\\\ \\gamma I \\end{bmatrix} \\] \\[ \\mathbf{f}^{\\text{out}} = \\begin{bmatrix} \\frac{\\beta I S}{N} \\\\ \\gamma I \\\\ 0 \\end{bmatrix} \\] 3.2 Flow Matrix Note that the outflow from \\(S\\) and inflow to \\(I\\) in the previous example has an identical magnitude. This is a common pattern in compartmental models. Many outflows are balanced perfectly by an associated inflow, to model individuals flowing from one compartment to another. McMasterPandemic assumes this balancing of flows to be the default situation, and therefore expresses both inflows and outflows in terms of an \\(n\\) by \\(n\\) flow matrix, \\(\\mathbf{F}\\), that only requires specifying a single expression for each inflow-outflow pair. The element in the \\(i\\)th row and \\(j\\)th column of the flow matrix gives the flow from state \\(i\\) to state \\(j\\). The default inflow and outflow vectors can therefore be computed as the column sums and row sums respectively. Continuing the SI model example, we have the following flow matrix. \\[ \\mathbf{F} = \\begin{bmatrix} 0 &amp; \\frac{\\beta I}{N}S &amp; 0 \\\\ 0 &amp; 0 &amp; \\gamma I \\\\ 0 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] There are times however where one wants a particular flow from one state to another to include only the inflow component and not the outflow. For example in cases where death removes individuals from the population. We consider this and other examples of asymmetric flow in later chapters (TODO). 3.3 Rate Matrix In modelling it is often more convenient to define per-capita rates of flow between compartments rather than total flow. The rate matrix, \\(\\mathbf{M}\\), contains these per-capita rates. The elements, \\(F_{ij}\\), of the flow matrix can be computed from the rate matrix and the state vector as follows. \\[ F_{ij} = M_{ij}s_i \\] The rate matrix for the SI model is given by the following expression. \\[ \\mathbf{M} = \\begin{bmatrix} 0 &amp; \\frac{\\beta I}{N} &amp; 0 \\\\ 0 &amp; 0 &amp; \\gamma \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix} \\] The elements of the rate matrix are determined by expressions involving elements of the state vector and parameters, which we collect into a paramter vector, \\(\\mathbf{\\theta}\\). For the SI model \\(\\mathbf{\\theta}\\) contains two parameters. \\[ \\mathbf{\\theta} = \\begin{bmatrix} \\beta \\\\ \\gamma \\\\ N \\end{bmatrix} \\] 3.4 Rate Matrix Dependence on State Variables and Parameters Currently it is not possible to specify elements of the rate matrix as arbitrary arithmetic expressions involving state variables and parameters – although we plan to add this functionality. However, there is a reasonable degree of flexibility. Each element of the rate matrix can be any expression that obeys the following rules. Any element, \\(x\\), of either the parameter or state vector can be used to define a factor in one of the following three forms. Identity: \\(x\\) Complement: \\(1-x\\) Inverse: \\(1/x\\) We collect these user-defined factors into a factor vector, \\(\\mathbf{y}\\). Factors can be repeated in \\(\\mathbf{y}\\) if required. Any number of factors can be multiplied together using * to produce a product. Any number of factors and products can be added together using +. There is the following higher level nested structure associated with the factor vector, \\(\\mathbf{y}\\). All factors associated with the, \\(i\\)th, non-zero rate matrix element, \\(M_{(i)}\\), are grouped together in a contiguous block within \\(\\mathbf{y}\\) Within the \\(i\\)th block, all factors associated with the \\(j\\)th product (\\(j = 1 ... n_i\\)) in that block are grouped together in a contiguous sub-block Within the \\(i,j\\)th sub-block, all factors are given an index, \\(k = 1 ... m_{ij}\\) With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression. \\[ M_{(i)} = \\sum_{j=1}^{n_i} \\prod_{k=1}^{m_{ij}} y_{ijk} \\] where \\(y_{ijk}\\) is the \\(k\\)th factor associated with the \\(j\\)th product associated with the \\(i\\)th non-zero rate matrix element. from to n-fctrs n-prdcts n-vrbls state-dependent time-varying sum-dependent S I 3 1 3 TRUE FALSE FALSE I R 1 1 1 FALSE FALSE FALSE McMasterPandemic is designed to be modular allow multiple definitions of valid expressions for the rate matrix. In later chapters we describe this possibility (TODO). 3.5 Next Steps "],["simulation.html", "Chapter 4 Simulation", " Chapter 4 Simulation All previous chapters were concerned with defining a compartmental model. In this chapter we switch to getting results from a defined model. Once a model object is defined, it can be used to generate simulations using the simulation_history function. simulation_history(sir) The output contains a column for the simulation date, one column for each state variable (S, I and R in this case), and one column for every time-varying rate (S_to_I). The names of the time-varying rates are always of the form {from_state}_to_{to_state}. The reason why S_to_I is time-varying in this model is that it depends on a state variable, I, which is itself varying at every time-step. The rate_summary function can be used to remind us of this fact. (sir %&gt;% rate_summary(include_formula = TRUE) %&gt;% select(from, to, formula) ) ## from to formula ## S_to_I S I (I) * (beta) * (1/N) ## I_to_R I R (gamma) We see here that S_to_I does indeed depend on I in its formula, whereas I_to_R depends only on a parameter, gamma. Note that the above command uses the tidyverse-style pipe, %&gt;%, operator and another tidyverse function, select. This illustrates a general philosophy of McMasterPandemic, which is that we try to make the outputs plug into other existing and popular tools rather than reinvent existing functionality for a narrower purpose. For example, the rate_summary function returns a data frame that can be manipulated by other data frame manipulation tools. We can plug into other existing and popular tools to make a plot of the simulated epidemic trajectory. (sir %&gt;% simulation_history %&gt;% select(-S_to_I) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Population&quot;) %&gt;% mutate(State = factor(State, levels = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;))) %&gt;% ggplot + geom_line(aes(Date, Population, colour = State)) ) "],["calibration.html", "Chapter 5 Calibration 5.1 Loss Functions", " Chapter 5 Calibration In the last chapter we showed how to simulate from a simple SIR model. Here we simulate and then manipulate the resulting data into the form that could be used to fit the model to data. This will demonstrate the model calibration capabilities of McMasterPandemic, which can be used to fit any number of model parameters to any number of observed time-series of the population sizes in the compartments of the model. For example, here we generate a time-series of infected individuals. synthetic_data = (sir %&gt;% simulation_history %&gt;% select(Date, I) %&gt;% pivot_longer(-Date, names_to = &quot;var&quot;, values_to = &quot;value&quot;) %&gt;% rename(date = Date) %&gt;% filter(date &gt; as.Date(&quot;2020-03-11&quot;)) ) rmarkdown::paged_table(synthetic_data) When fitting data to a model a specific format must be used. In particular there must be exactly these three columns. date – gives the date associated with each observation var – gives the name of the state variable to compare value – gives the observed value to compare with the simulated state variable In this particular case there is only a single state variable used, but this need not be the case. We next construct a model that contains two new ingredients that we have not yet seen: (1) observed time-series data and (2) information on what parameters to fit and how to fit them. sir_to_calibrate = (flexmodel( params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot;, data = synthetic_data ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) %&gt;% update_opt_params(log_beta ~ log_flat(0)) ) opt = nlminb_flexmodel(sir_to_calibrate) ## Constructing atomic D_lgamma ## outer mgc: 14.42568 ## Constructing atomic D_lgamma ## outer mgc: 33.72914 ## outer mgc: 270.8903 ## outer mgc: 68.90791 ## outer mgc: 12.11199 ## outer mgc: 0.7019154 ## outer mgc: 0.002853259 ## outer mgc: 4.77606e-08 opt$opt_obj ## $par ## log_beta ## -2.302585 ## ## $objective ## [1] 1128.702 ## ## $convergence ## [1] 0 ## ## $iterations ## [1] 7 ## ## $evaluations ## function gradient ## 9 8 ## ## $message ## [1] &quot;relative convergence (4)&quot; opt$opt_par ## log_beta ## -2.302585 5.1 Loss Functions 5.1.1 Negative Binomial \\[ \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\left(\\frac{k}{k + \\mu}\\right)^k \\left(\\frac{\\mu}{k + \\mu}\\right)^x \\] \\[ \\log\\Gamma(x+k) - \\log\\Gamma(k) - \\log(x!) + k \\log\\left(\\frac{k}{k + \\mu}\\right) + x\\log\\left(\\frac{\\mu}{k + \\mu}\\right) \\] "],["outflows.html", "Chapter 6 Outflows 6.1 Standard Inflow-Outflow Balance 6.2 Accumulators", " Chapter 6 Outflows In compartmental modelling we typically want to balance each flow out of a boxes with an equal flow into another box. This is because individuals are simply changing their epidemiological status as they move between boxes, and the total number of individuals across the boxes remains constant. 6.1 Standard Inflow-Outflow Balance McMasterPandemic makes it very easy to declare this standard balance between inflows and outflows to any model by simply adding add_outflow to your model definition pipeline. sir = (init_model( params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) %&gt;% add_outflow ) ## Warning in init_model(params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, : ## init_model is deprecated. ## please use flexmodel. ## the only difference between the two functions is the name. If we had not added the add_outflow line, the previous add_rate calls would have caused flows into I from S and into R from I. The add_outflow line adds flows out of S to I and out of I to R. A simple interpretation of the S to I rate without add_outflow is to imagine that S-individuals give birth to I-individuals. Because S-individuals do not die at childbirth, there is no outflow from the S box. This interface design makes it very easy to enforce inflow-outflow balance. This ease of use contrasts with the standard practice of writing down difference or differential equations to define the model (e.g. POMP, STAN). This equation-style interface requires that the user make sure each inflow term in one equation is appropriately balanced by an outflow term in another equation. In McMasterPandemic you define the inflows, and then a single call of add_outflow automatically creates balancing outflows. 6.2 Accumulators Accumulator compartments are those that do not allow "],["hazard-smoothing.html", "Chapter 7 Hazard Smoothing", " Chapter 7 Hazard Smoothing "],["state-initialization.html", "Chapter 8 State Initialization", " Chapter 8 State Initialization "],["vector-rates.html", "Chapter 9 Vector Rates", " Chapter 9 Vector Rates "],["time-varying-parameters.html", "Chapter 10 Time Varying Parameters 10.1 Example Time-Variation Schedules", " Chapter 10 Time Varying Parameters Any parameter in a McMasterPandemic model can be scheduled to vary in time. A time-variation schedule is a data frame with one row for each date on which each parameter changes its value. This data frame has four columns: Date – Date on which a particular parameter changes its value Symbol – String giving the symbol representing the changing parameter Value – The numeric value used to change the value of the parameter, the effect of which depends on the value of the Type column Type – One of the following strings: \"abs\" – The Value column is the new value for the parameter on Date \"rel_orig\" – The Value column is multiplied by the original value of the changing parameter at the beginning of the simulation, to generate a new value for the parameter on Date \"rel_prev\" – The Value column is multiplied by the previous value of the changing parameter, to generate a new value for the parameter on Date Entries in the Value column can be NA, indicating that these should be calibrated. 10.1 Example Time-Variation Schedules "],["examples.html", "Chapter 11 Examples 11.1 Hello World: Simulating an SIR Model 11.2 SEIR 11.3 Structure: Two-Strain SIR 11.4 Erlang SEIR 11.5 The SIRV model 11.6 Variolation model 11.7 SEIRD Model 11.8 Covid SEIR 11.9 BC Covid Omicron 11.10 Classic McMasterPandemic", " Chapter 11 Examples library(dplyr) library(tidyr) library(lubridate) 11.1 Hello World: Simulating an SIR Model state = c(S = 20000, I = 100, R = 0) sir_model = ( flexmodel( params = c( gamma = 0.06, beta = 0.15, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (1/N) * (beta) * (I)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) sir_model ## from to n_fctrs n_prdcts n_vrbls state_dependent time_varying ## S_to_I S I 3 1 3 TRUE FALSE ## I_to_R I R 1 1 1 FALSE FALSE ## sum_dependent ## S_to_I FALSE ## I_to_R FALSE (sir_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) (sir_model %&gt;% simulate_changing_ratemat_elements(add_dates = TRUE) %&gt;% rename(`force of infection` = S_to_I) %&gt;% ggplot + geom_line(aes(x = Date, y = `force of infection`)) ) 11.2 SEIR state = c(S = 20000, E = 0, I = 100, R = 0) seir_model = ( flexmodel( params = c( alpha = 0.05, gamma = 0.06, beta = 0.15, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE, ) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (1/N) * (beta) * (I)) %&gt;% add_rate(&quot;E&quot;, &quot;I&quot;, ~ (alpha)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) seir_model ## from to n_fctrs n_prdcts n_vrbls state_dependent time_varying ## S_to_E S E 3 1 3 TRUE FALSE ## E_to_I E I 1 1 1 FALSE FALSE ## I_to_R I R 1 1 1 FALSE FALSE ## sum_dependent ## S_to_E FALSE ## E_to_I FALSE ## I_to_R FALSE 11.3 Structure: Two-Strain SIR strains = c(&quot;wild&quot;, &quot;variant&quot;) state = c( S = 20000, I_wild = 49, I_variant = 1, R_wild = 0, R_variant = 0 ) two_strain_model = ( flexmodel( params = c( gamma = 0.06, beta_wild = 0.15, beta_variant = 0.25, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE ) %&gt;% vec_rate( &quot;S&quot;, &quot;I&quot; %_% strains, vec(&quot;beta&quot; %_% strains) * struc(&quot;1/N&quot;) * vec(&quot;I&quot; %_% strains) ) %&gt;% rep_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) regex = &quot;^(S|I|R)(_*)(.*)&quot; (two_strain_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value) %&gt;% mutate(strain = sub(pattern = regex, replacement = &quot;\\\\3&quot;, name)) %&gt;% mutate(epi_cat = sub(pattern = regex, replacement = &quot;\\\\1&quot;, name)) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat, linetype = strain)) ) (two_strain_model %&gt;% simulate_changing_ratemat_elements(add_dates = TRUE) %&gt;% pivot_longer(starts_with(&quot;S_to_I&quot;)) %&gt;% mutate(name = sub(&quot;S_to_I_&quot;, &quot;&quot;, name)) %&gt;% rename(`force of infection` = value) %&gt;% rename(strain = name) %&gt;% ggplot + geom_line(aes(x = Date, y = `force of infection`, colour = strain)) ) 11.4 Erlang SEIR David, Jonathan, and David describe the Erlang SEIR model in continuous time. Here is a discrete time version of it. n = 4 # number of I states m = 6 # number of E states erlang_seir = (flexmodel( # FIXME: only working for no demography (so mu = 0 for now) params = c(mu = 0, beta = 1.5, m = m, n = n, gamma = 1.2, sigma = 0.1), state = c( S = 1-1e-3, layered_zero_state(&quot;E&quot; %_% 1:m), I_1 = 1e-3, layered_zero_state(&quot;I&quot; %_% 2:n), R = 0, D = 0, . = 1), start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-04-01&quot;, do_hazard = TRUE ) %&gt;% add_state_param_sum(&quot;I&quot;, &quot;^I_[0-9]+&quot;) # birth %&gt;% add_rate(&quot;.&quot;, &quot;S&quot;, ~ (mu)) # death %&gt;% rep_rate( from = c(&quot;S&quot;, &quot;E&quot; %_% 1:m, &quot;I&quot; %_% 1:n, &quot;R&quot;), to = &quot;D&quot;, formula = ~ (mu)) # infection %&gt;% add_rate(&quot;S&quot;, &quot;E_1&quot;, ~ (beta) * (I)) # become infectious %&gt;% add_rate(&quot;E&quot; %_% m, &quot;I_1&quot;, ~ (m) * (sigma)) # sojourn through exposed compartments %&gt;% rep_rate( &quot;E&quot; %_% 1:(m-1), &quot;E&quot; %_% 2:m, ~ (m) * (sigma) ) # sojourn through infectious compartments %&gt;% rep_rate( &quot;I&quot; %_% 1:(n-1), &quot;I&quot; %_% 2:n, ~ (n) * (gamma) ) # recovery %&gt;% add_rate(&quot;I&quot; %_% n, &quot;R&quot;, ~ (n) * (gamma)) # nothing flows out of . because it is a dummy # state used to generate flows that are not per-capita %&gt;% add_outflow(&quot;[^.]&quot;) ) (erlang_seir %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% select(-., -D) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Count&quot;) %&gt;% mutate(State = sub(&quot;_[0-9]+&quot;, &quot;&quot;, State)) %&gt;% group_by(Date, State) %&gt;% summarise(Count = sum(Count)) %&gt;% ungroup %&gt;% ggplot() + geom_line(aes(Date, Count, colour = State)) ) ## `summarise()` has grouped output by &#39;Date&#39;. You can override using the ## `.groups` argument. # check to make sure that the population density # remains constant at one (erlang_seir %&gt;% simulate_state_vector(add_dates = FALSE) %&gt;% select(-., -D) %&gt;% rowSums %&gt;% sapply(all.equal, 1L) %&gt;% sapply(isTRUE) %&gt;% all ) ## [1] TRUE 11.5 The SIRV model state = c(S = 20000, I = 100, R = 0, V = 0) params = c( gamma = 0.06, beta = 0.15, v = 0, # initial vaccination rate N = sum(state) ) # roll out the vaccine by bumping the # vaccination rate twice params_timevar = data.frame( Date = c(&quot;2020-02-01&quot;, &quot;2020-03-01&quot;), Symbol = c(&quot;v&quot;, &quot;v&quot;), Value = c(0.01, 0.1), Type = c(&quot;abs&quot;, &quot;abs&quot;)) sirv_model = ( flexmodel( params = params, state = state, params_timevar = params_timevar, start_date = &quot;2020-01-01&quot;, end_date = &quot;2020-05-01&quot;, do_hazard = TRUE ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (beta) * (1/N) * (I)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) %&gt;% add_rate(&quot;S&quot;, &quot;V&quot;, ~ (v)) ) (sirv_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) + geom_vline(aes(xintercept = as.Date(Date)), data = params_timevar, colour = &#39;lightgrey&#39;) ) 11.6 Variolation model state = c( S = 20000, I_severe = 50, I_mild = 50, R_mild = 0, R_severe = 0 ) params = c( nu = 0.0105, # birth rate mu = 0.0105, # death rate delta = 1/7, # waning immunity rate gamma_mild = 1/(3.3 + 9), # recovery rate of mild cases gamma_severe = 1/(3.3 + 14), # recovery rate of severe cases beta_mild = 0.15, # transmission rate of infections leading to mild cases beta_severe = 0.3, # transmission rate of infections leading to severe cases m = 0.6 # probability of developing mild illness ) # model structure all_states = names(state) severity = c(&quot;mild&quot;, &quot;severe&quot;) beta_vec = vec(&quot;beta&quot; %_% severity) I_vec = vec(&quot;I&quot; %_% severity) foi = kronecker(vec(&quot;m&quot;, &quot;1-m&quot;), sum(beta_vec * I_vec * struc(&quot;1/N&quot;))) variolation_model &lt;- ( flexmodel( params = params, state = state, start_date = &quot;2020-01-01&quot;, end_date = &quot;2020-04-01&quot; ) %&gt;% add_state_param_sum(&quot;N&quot;, any_var(state)) # births and deaths # (FIXME: this only works if nu = mu) %&gt;% rep_rate( all_states, &quot;S&quot;, ~ (nu) ) # infection %&gt;% vec_rate( &quot;S&quot;, &quot;I&quot; %_% severity, foi ) # waning immunity %&gt;% rep_rate( &quot;R&quot; %_% severity, &quot;S&quot;, ~ (delta) ) # recovery %&gt;% vec_rate( &quot;I&quot; %_% severity, &quot;R&quot; %_% severity, vec(&quot;gamma&quot; %_% severity) ) ) (variolation_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) 11.7 SEIRD Model This is the Mac Theo Bio Model. state = c(S = 20000, E = 50, I = 50, R = 0, D = 0, Null = 0) params = c( # transmission rates of susceptibles from live and dead individuals beta_I = 5, beta_D = 2, # average times in various boxes T_E = 10, T_I = 14, T_D = 10, # probability of death given infection f = 0.5 ) seird_model = ( flexmodel( params = params, state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-03-01&quot;, do_hazard = TRUE ) %&gt;% add_state_param_sum(&quot;N&quot;, any_var(state)) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (beta_I) * (1/N) * (I) + (beta_D) * (1/N) * (D)) %&gt;% add_rate(&quot;E&quot;, &quot;I&quot;, ~ (1/T_E)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (1/T_I) * (1 - f)) %&gt;% add_rate(&quot;I&quot;, &quot;D&quot;, ~ (1/T_I) * (f)) %&gt;% add_rate(&quot;D&quot;, &quot;Null&quot;, ~ (1/T_D)) ) (seird_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) 11.8 Covid SEIR The BC covid modelling group uses this compartmental model for their inference and forecasting work. This model can be expressed in McMasterPandemic with the following. foi = ( vec(c(&quot;1&quot;, &quot;f&quot;)) * struc(&quot;beta&quot;) * struc(&quot;1/N&quot;) * (struc(&quot;(I) + (E2)&quot;) + (struc(&quot;f&quot;) * struc(&quot;(Id) + (E2d)&quot;))) ) params = c( N = 5100000, D = 5, k1 = 0.2, k2 = 1, q = 0.05, ud = 0.1, ur = 0.02, psir = 0.3, shape = 1.73, scale = 9.85, beta = 0.433, f = 1 ) state = c( S = 849999, E1 = 0.53, E2 = 0.13, I = 0.67, Q = 0, R = 0, Sd = 4249993, E1d = 2.67, E2d = 0.67, Id = 3.33, Qd = 0, Rd = 0 ) base_states = names(state)[1:6] dist_states = base_states %+% &quot;d&quot; strats = c(&quot;&quot;, &quot;d&quot;) # distancing strategies ramp_period = seq(from = ymd(20210315), to = ymd(20210322), by = 1) time_ratio = rev((seq_along(ramp_period) - 1) / (length(ramp_period) - 1)) f2 = 0.22 params_timevar = data.frame( Date = ramp_period, Symbol = rep(&quot;f&quot;, length(ramp_period)), Value = f2 + time_ratio * (1 - f2), Type = rep(&quot;abs&quot;, length(ramp_period)) ) model = ( flexmodel( params = params, state = state, start_date = &quot;2021-02-01&quot;, end_date = &quot;2021-06-01&quot;, do_hazard = TRUE, params_timevar = params_timevar ) # flow between distancing strategies %&gt;% rep_rate(base_states, dist_states, ~ (ud)) %&gt;% rep_rate(dist_states, base_states, ~ (ur)) # force of infection %&gt;% vec_rate( &quot;S&quot; %+% strats, &quot;E1&quot; %+% strats, foi ) # flow within distancing strategies %&gt;% rep_rate( &quot;E1&quot; %+% strats, &quot;E2&quot; %+% strats, ~ (k1) ) %&gt;% rep_rate( &quot;E2&quot; %+% strats, &quot;I&quot; %+% strats, ~ (k2) ) %&gt;% rep_rate( &quot;I&quot; %+% strats, &quot;Q&quot; %+% strats, ~ (q) ) %&gt;% rep_rate( expand_names(c(&quot;I&quot;, &quot;Q&quot;), strats, &quot;&quot;), expand_names(c(&quot;R&quot;, &quot;R&quot;), strats, &quot;&quot;), ~ (1/D) ) ) (model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% ggplot() + facet_wrap(~ name, scales = &#39;free&#39;, ncol = 2) + geom_line(aes(Date, value)) ) 11.9 BC Covid Omicron The BC group also developed a model with two strains for the Omicron wave of Covid-19. DISCLAIMER: This is not meant to illustrate a realistic forecast, but rather to illustrate how the basic model structure can be expressed in McMasterPandemic params = c( sigma=1/3, # incubation period (3 days) (to fixed) gamma=1/(5), #recovery rate (fixed) nu =0.007, #vax rate: 0.7% per day (fixed) mu=1/(82*365), # 1/life expectancy (fixed) w1 = 1/(3*365),# waning rate from R to S (fixed) w2 = 1/(3*365), # waning rate from Rv to V (fixed) w3 = 1/(3*365),# waning rate Rw to W (fixed) ve=1, # I think this should be 1. it is not really efficacy ( fixed) beta_r=0.72, #transmission rate (to estimate) (0.35) beta_m=0.8*2.2, #transmission rate (to estimate)(*1.9) epsilon_r = (1-0.8), # % this should be 1-ve epsilon_m = (1-0.6), # % escape capacity #(fixed) b= 0.006, # booster rate (fixed) beff = 0.7, # booster efficacy wf=0.2, # protection for newly recoverd #0.2 N=5e6, E0=5, S0=1-1e-5, c=1 ) # dimensions of model structure vax_states = c(&quot;unvax&quot;, &quot;onedose&quot;, &quot;boost&quot;) variant_states = c(&quot;delta&quot;, &quot;omicron&quot;) epi_states = c(&quot;S&quot;, &quot;E&quot; %_% variant_states, &quot;I&quot; %_% variant_states, &quot;R&quot;) # vectors representing variant model structure I_delta = vec(&quot;I&quot; %_% &quot;delta&quot; %_% vax_states) I_omicron = vec(&quot;I&quot; %_% &quot;omicron&quot; %_% vax_states) E_delta = vec(&quot;E&quot; %_% &quot;delta&quot; %_% vax_states) E_omicron = vec(&quot;E&quot; %_% &quot;omicron&quot; %_% vax_states) # initial state vector state = layered_zero_state(epi_states, vax_states) all_states = names(state) state[] = unname(make_init(params)) print(state) ## S_unvax E_delta_unvax E_omicron_unvax I_delta_unvax ## 9.106607e+05 6.480000e+02 1.748571e+01 1.110857e+03 ## I_omicron_unvax R_unvax S_onedose E_delta_onedose ## 2.997551e+01 1.014000e+05 3.502789e+06 5.924571e+02 ## E_omicron_onedose I_delta_onedose I_omicron_onedose R_onedose ## 1.974857e+01 1.015641e+03 3.385469e+01 3.893760e+05 ## S_boost E_delta_boost E_omicron_boost I_delta_boost ## 1.460132e+05 2.468571e+01 8.228571e-01 4.231837e+01 ## I_omicron_boost R_boost ## 1.410612e+00 1.622400e+04 two_strain_bc = (flexmodel( params = params, state = state, start_date = &quot;2022-01-01&quot;, end_date = &quot;2022-05-01&quot;, do_hazard = TRUE ) # sum over every vax status to get # total numbers in I boxes for each # variant %&gt;% add_state_param_sum(&quot;I_delta&quot;, &quot;I_delta_&quot;) %&gt;% add_state_param_sum(&quot;I_omicron&quot;, &quot;I_omicron_&quot;) # R to S boxes for every vax status # -- waning %&gt;% vec_rate( from = &quot;R&quot; %_% vax_states, to = &quot;S&quot; %_% vax_states, vec(&#39;w1&#39;, &#39;w2&#39;, &#39;w3&#39;) ) # S_delta to E_delta for every vax status # -- delta force of infection %&gt;% vec_rate( from = &quot;S&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;delta&quot; %_% vax_states, struc(&quot;(c) * (beta_r) * (1/N) * (I_delta)&quot;) * vec(&quot;1&quot;, &quot;epsilon_r&quot;, &quot;epsilon_r&quot;) ) # S_omicron to E_omicron for every vax status # -- omicron force of infection %&gt;% vec_rate( from = &quot;S&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;omicron&quot; %_% vax_states, struc(&quot;(c) * (beta_m) * (1/N) * (I_omicron)&quot;) * vec(&quot;1&quot;, &quot;epsilon_m&quot;, &quot;epsilon_m&quot;) ) # R to E_delta for every vax status # -- delta force of infection of recovered individuals %&gt;% rep_rate( from = &quot;R&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;delta&quot; %_% vax_states, ~ (wf) * (epsilon_r) * (c) * (beta_r) * (1/N) * (I_delta) ) # R to E_omicron for every vax status # -- omicron force of infection of recovered individuals %&gt;% rep_rate( from = &quot;R&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;omicron&quot; %_% vax_states, ~ (wf) * (epsilon_m) * (c) * (beta_m) * (1/N) * (I_omicron) ) # E to I for all variant-vax combinations %&gt;% rep_rate( from = &quot;E&quot; %_% expand_names(variant_states, vax_states), to = &quot;I&quot; %_% expand_names(variant_states, vax_states), ~ (sigma) ) # recovery for all variant-vax combinations %&gt;% rep_rate( from = &quot;I&quot; %_% expand_names(variant_states, vax_states), to = &quot;R&quot; %_% rep(vax_states, each = length(variant_states)), ~ (gamma) ) # demographics %&gt;% rep_rate( from = all_states, to = &quot;S_unvax&quot;, ~ (mu) ) # vaccination %&gt;% add_rate(from = &quot;S_unvax&quot;, to = &quot;S_onedose&quot;, ~ (nu) * (ve)) %&gt;% add_rate(from = &quot;S_onedose&quot;, to = &quot;S_boost&quot;, ~ (b) * (ve)) ) category_pattern = &quot;^(S|E|I|R)(_omicron|_delta)?_(unvax|onedose|boost)$&quot; (two_strain_bc %&gt;% simulate_state_vector(add_date = TRUE) %&gt;% pivot_longer(-Date, names_to = &quot;Compartment&quot;, values_to = &quot;State&quot;) %&gt;% mutate(`Epi Status` = sub(category_pattern, &#39;\\\\1\\\\2&#39;, Compartment, perl = TRUE)) %&gt;% mutate(`Vaccination Status` = sub(category_pattern, &#39;\\\\3&#39;, Compartment, perl = TRUE)) %&gt;% arrange(`Epi Status`, `Vaccination Status`) %&gt;% mutate(Compartment = factor(Compartment, all_states)) %&gt;% ggplot() + facet_wrap( ~ Compartment, ncol = 3, scales = &#39;free&#39;, dir = &#39;v&#39;) + geom_line(aes(Date, State)) ) 11.10 Classic McMasterPandemic params = read_params(&quot;ICU1.csv&quot;) model = (flexmodel( params = params, state = make_state(params = params), start_date = &quot;2020-03-10&quot;, end_date = &quot;2020-12-10&quot;, do_make_state = FALSE, do_hazard = TRUE ) %&gt;% add_rate(&quot;E&quot;, &quot;Ia&quot;, ~ (alpha) * (sigma)) %&gt;% add_rate(&quot;E&quot;, &quot;Ip&quot;, ~ (1 - alpha) * (sigma)) %&gt;% add_rate(&quot;Ia&quot;, &quot;R&quot;, ~ (gamma_a)) %&gt;% add_rate(&quot;Ip&quot;, &quot;Im&quot;, ~ (mu) * (gamma_p)) %&gt;% add_rate(&quot;Ip&quot;, &quot;Is&quot;, ~ (1 - mu) * (gamma_p)) %&gt;% add_rate(&quot;Im&quot;, &quot;R&quot;, ~ (gamma_m)) %&gt;% add_rate(&quot;Is&quot;, &quot;H&quot;, ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;ICUs&quot;, ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;ICUd&quot;, ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;D&quot;, ~ (nonhosp_mort) * (gamma_s)) %&gt;% add_rate(&quot;ICUs&quot;, &quot;H2&quot;, ~ (psi1)) %&gt;% add_rate(&quot;ICUd&quot;, &quot;D&quot;, ~ (psi2)) %&gt;% add_rate(&quot;H2&quot;, &quot;R&quot;, ~ (psi3)) %&gt;% add_rate(&quot;H&quot;, &quot;R&quot;, ~ (rho)) %&gt;% add_rate(&quot;Is&quot;, &quot;X&quot;, ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (Ia) * (beta0) * (1 / N) * (Ca) + (Ip) * (beta0) * (1 / N) * (Cp) + (Im) * (beta0) * (1 / N) * (Cm) * (1 - iso_m) + (Is) * (beta0) * (1 / N) * (Cs) * (1 - iso_s)) %&gt;% add_outflow(&quot;.+&quot;, &quot;^(S|E|I|H|ICU|D|R)&quot;) ) (model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% ggplot() + facet_wrap(~ name, scales = &#39;free&#39;, ncol = 3) + geom_line(aes(Date, value)) ) "],["troubleshooting.html", "Chapter 12 Troubleshooting 12.1 NaN-Valued Objective Function", " Chapter 12 Troubleshooting 12.1 NaN-Valued Objective Function 12.1.1 Simulated time-series close to zero When the simulated values that are being compared with data are close to zero (e.g. less than 1e-12), the negative binomial loss function often returns NaN. This can be fixed by setting do_sim_constraint = TRUE as an argument to flexmodel or whatever model constructor is being used (e.g. make_vaccination_model). This flag causes the simulated values to pass through the following soft-thresholding function to keep the simulations, \\(x\\), from falling below a tolerance, \\(\\epsilon\\). \\[ x + \\epsilon \\exp\\left(-\\frac{x}{\\epsilon}\\right) \\] This tolerance can be adjusted by setting the sim_lower_bound = 1e-12. Note that both do_sim_constraint and sim_lower_bound get be set using the global options MP_default_do_sim_constraint and MP_default_sim_lower_bound. 12.1.2 Negative rate matrix elements These can arise naturally due to time-varying parameters that appear in 1-x terms in rate formulas. The best way to avoid this is to use the abs type of time-variation, so that logit transformations can be used directly on the changing parameters. This approach ensures that the parameter never leaves the interval between zero and one. In the future we should have a time-variation option that updates changing parameters on the logit scale, which would also solve this problem. 12.1.3 Optimizer tries very large dispersion parameters For some reason the TMB dnbinom2 function cannot handle large dispersion parameters, even though the standard R dnbinom function seems fine with them. Nevertheless, this entire issue can be avoided by setting priors on the dispersion parameters. In the future we might try to exploit the fact that the limit of the log negative binomial density as the dispersion parameter gets large tends to \\(-\\log(x!)\\), where \\(x\\) is the observed count. Such an improvement is not entirely trivial due to the need for maintaining differentiability. "]]
