[["index.html", "Generalized McMasterPandemic 1 Fast and Flexible Modelling with McMasterPandemic 1.1 Installation 1.2 Dependencies 1.3 Generalized Model at a Glance", " Generalized McMasterPandemic Steve Walker 2022-05-05 1 Fast and Flexible Modelling with McMasterPandemic McMasterPandemic is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This guide describes how to use this refactored version of McMasterPandemic. 1.1 Installation This generalized McMasterPandemic framework is still in an experimental phase. Therefore you will need to install the tmb-condense code branch that contains the experimental implementation directly from github. A convenient way to do this is to use the remotes package as follows. remotes::install_github(&quot;mac-theobio/McMasterPandemic@tmb-condense&quot;) 1.2 Dependencies This guide makes use of the following session. sessionInfo() ## R version 4.2.0 (2022-04-22) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur/Monterey 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] lubridate_1.8.0 tidyr_1.2.0 ## [3] McMasterPandemic_0.0.20.1 dplyr_1.0.9 ## [5] RcppEigen_0.3.3.9.2 TMB_1.8.1 ## [7] ggplot2_3.3.6 ## ## loaded via a namespace (and not attached): ## [1] shape_1.4.6 diagram_1.6.5 tidyselect_1.1.2 ## [4] xfun_0.30 bslib_0.3.1 purrr_0.3.4 ## [7] splines_4.2.0 lattice_0.20-45 colorspace_2.0-3 ## [10] vctrs_0.4.1 generics_0.1.2 htmltools_0.5.2 ## [13] stats4_4.2.0 yaml_2.3.5 utf8_1.2.2 ## [16] rlang_1.0.2 jquerylib_0.1.4 pillar_1.7.0 ## [19] glue_1.6.2 withr_2.5.0 semver_0.2.0 ## [22] foreach_1.5.2 lifecycle_1.0.1 stringr_1.4.0 ## [25] munsell_0.5.0 gtable_0.3.0 bdsmatrix_1.3-4 ## [28] mvtnorm_1.1-3 codetools_0.2-18 evaluate_0.15 ## [31] forcats_0.5.1 knitr_1.39 tzdb_0.3.0 ## [34] fastmap_1.1.0 fansi_1.0.3 Rcpp_1.0.8.3 ## [37] readr_2.1.2 scales_1.2.0 fastmatrix_0.4-1 ## [40] jsonlite_1.8.0 hms_1.1.1 digest_0.6.29 ## [43] stringi_1.7.6 bookdown_0.26 numDeriv_2016.8-1.1 ## [46] grid_4.2.0 cli_3.3.0 tools_4.2.0 ## [49] bbmle_1.0.24 magrittr_2.0.3 sass_0.4.1 ## [52] tibble_3.1.7 crayon_1.5.1 pkgconfig_2.0.3 ## [55] MASS_7.3-56 ellipsis_0.3.2 Matrix_1.4-1 ## [58] rmarkdown_2.14 rstudioapi_0.13 iterators_1.0.14 ## [61] R6_2.5.1 compiler_4.2.0 1.3 Generalized Model at a Glance The general model underlying McMasterPandmic’s flexible engine and interface based on a discrete time compartmental model. \\[ s_{i,t+1} = s_{i,t} + \\underbrace{\\sum_j M_{ji,t} s_{j,t}}_{\\text{inflow}} - \\underbrace{s_{i,t} \\sum_j M_{ij,t} {\\mathcal I}_{ij}}_{\\text{outflow}} \\] where, \\(s_{i,t}\\) is the state of the \\(i\\)th compartment at time \\(t\\) \\(M_{ij,t}\\) is the per-capita rate of flow from compartment \\(i\\) to compartment \\(j\\) at time \\(t\\) \\({\\mathcal I}_{ij}\\in\\{0,1\\}\\) indicates whether or not individuals should be removed from compartment \\(i\\) after flowing to compartment \\(j\\) The per-capita rates, \\(M_{ij,t}\\), can be any expression involving only sums and products of any of the following at time \\(t\\): State of any compartment Model parameter – either time-varying or not Complements of any of the above (i.e. \\(1-x\\)) Inverses of any of the above (i.e. \\(1/x\\)) "],["simple-model-initializtion.html", "2 Simple Model Initializtion 2.1 Initial Parameter Vector 2.2 Initial State Vector 2.3 Start and End Date 2.4 Next Steps", " 2 Simple Model Initializtion Before one may define the dynamics of their compartmental model they must initialize it using the flexmodel function. Here we describe each of the basic and required arguments to flexmodel and how to set them. This function allows one to define many details of the model, but in this chapter we cover just the requirements. Parameter vector State vector Start and end dates Here is a simple SIR model example. sir = flexmodel( params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) To learn more about these options, please keep reading this chapter. To continue building this simple SIR model, please move on the the next chapter, where you can define Flow Between States. 2.1 Initial Parameter Vector The parameter vector contains the following kinds of information. State transition rates or parameters determining them (e.g. transmission rate, \\(\\beta\\)) Initial numbers of individuals in a compartment or group of compartments (e.g. initial number of exposed individuals, \\(E_0\\)) Data processing parameters to make observed and simulated time-series more comparable (e.g. fraction of incidence reported as positive tests, \\(c_\\text{prop}\\)) In its simplest form these parameters can be specified as a standard named numeric vector. We used this approach above in our SIR example, and this parameter vector can be extracted from the model. sir$params ## beta gamma N ## 1e-01 1e-02 1e+02 McMasterPandemic also has a special params_pansim object class for representing parameters. These objects come with descriptions of the meaning of each parameter. An example of this params_pansim format can be explored with the following command. rmarkdown::paged_table(describe_params(read_params(&#39;ICU1.csv&#39;))) See the McMasterPandemic getting started vignette for more info on params_pansim objects. 2.2 Initial State Vector The state vector is used to declare the names of the state variables. In the SIR example above we did this via a named numeric vector, and these names become the names of the states. sir$state ## S I R ## 99 1 0 The numbers in this vector can be used as initial values in simulations, but often the initial values will depend on the parameters (see do_make_state TODO). In these cases where the initial state is computed as opposed to specified, the state argument to init_model can just be character vector giving the names of the state variables. Classic McMasterPandemic also has a state_pansim object type (TODO: describe). 2.3 Start and End Date The simulation model takes a step every day. The start_date and end_date arguments give start and end of these simulations. The format of these dates can be supplied in any format that is accepted by as.Date without any formatting options. 2.4 Next Steps Models can be initialized with more complex features including time-varying parameters, hazard steps, and model linearization for computing state vectors that lead to greater stability (TODO: link to chapters/sections). But before getting to these complexities there is something more important: definition of the flows of individuals amongst the states (TODO: link to next chapter). "],["flow-between-states.html", "3 Flow Between States 3.1 State Flows 3.2 Flow Matrix 3.3 Rate Matrix 3.4 Rate Matrix Dependence on State Variables and Parameters 3.5 Next Steps", " 3 Flow Between States Here we describe the definition of the basic model of flows among states. Later chapters describe extensions to this basic model, both implemented (TODO) and unimplemented (TODO). The per-capita rate of flow between any two states can be defined using the add_rate function. sir = (sir %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) The first add_rate function says that on each simulated day, individuals flow from the S box to the I box at a rate equal to the product of I, beta, and 1/N. This rate is a per-capita rate, and so the flow of individuals from S to I is S times the rate. Similarly, the second add_rate function says that I times gamma individuals flow from I to R every simulated day. Here are the rules of these rate formulas (although these can be relaxed to some degree using techniques covered in later chapters). both state variables and parameters can be referred to by name as variables in the formulas variables must be encapsulated with parentheses variables can be converted to their inverse (1/x) or complement (1-x) varaibles, their inverses, and their complements can be combined using + and * operators Examples of valid rate formulas for this model include: (1-gamma) * (S) + (gamma) (1/I) (beta) * (gamma) + (beta) * (1/N) * (1-gamma) Examples of invalid rate formulas include: 1-gamma – no parentheses around this complement beta * gamma – no parentheses around variables (but this can be addressed using struc objects – TODO: link to these) ((S) + (R)) * (beta) – general grouping parentheses and common factors are not allowed (but this can be addressed using struc objects or intermediate computations – TODO: link to these) (E) * (beta) – the variable E is in neither the parameter nor state variable The remainder of this chapter describes the theory behind these rates, and clarifies what they mean. To start using this simple SIR model, please move on the the next chapter where you will learn how to do Simulation and explore epidemic trajectories. 3.1 State Flows The numbers of individuals in each compartment is stored in the state vector, \\(\\mathbf{s}\\), which contains one element for each compartment. At each time step, \\(t\\), the state vector is given by \\(\\mathbf{s}(t)\\). The relationship between the state vector at successive time steps is given by the following. \\[ \\mathbf{s}(t+1) = \\mathbf{s}(t) + \\mathbf{f}^{\\text{in}}(t) - \\mathbf{f}^{\\text{out}}(t) \\] where \\(\\mathbf{f}^{\\text{in}}\\) and \\(\\mathbf{f}^{\\text{out}}\\) are the inflow and outflow vectors. Continuing our concrete SIR model example, individuals flow from a box of susceptible individuals to infected to recovered individuals. \\[ S(t+1) = S(t) - \\frac{\\beta I(t)}{N}S(t) \\] \\[ I(t+1) = I(t) + \\frac{\\beta I(t)}{N}S(t) - \\gamma I(t) \\] \\[ R(t+1) = R(t) + \\gamma I(t) \\] where \\(\\beta\\), \\(\\gamma\\), and \\(N\\) are the transmission rate and population size parameters. In this model the inflow to the \\(S\\) box is zero and the outflow from \\(R\\) is also zero. Therefore we can express this model in general terms as the following. \\[ \\mathbf{s} = \\begin{bmatrix} S \\\\ I \\\\ R \\end{bmatrix} \\] \\[ \\mathbf{f}^{\\text{in}} = \\begin{bmatrix} 0 \\\\ \\frac{\\beta I S}{N} \\\\ \\gamma I \\end{bmatrix} \\] \\[ \\mathbf{f}^{\\text{out}} = \\begin{bmatrix} \\frac{\\beta I S}{N} \\\\ \\gamma I \\\\ 0 \\end{bmatrix} \\] 3.2 Flow Matrix Note that the outflow from \\(S\\) and inflow to \\(I\\) in the previous example has an identical magnitude. This is a common pattern in compartmental models. Many outflows are balanced perfectly by an associated inflow, to model individuals flowing from one compartment to another. McMasterPandemic assumes this balancing of flows to be the default situation, and therefore expresses both inflows and outflows in terms of an \\(n\\) by \\(n\\) flow matrix, \\(\\mathbf{F}\\), that only requires specifying a single expression for each inflow-outflow pair. The element in the \\(i\\)th row and \\(j\\)th column of the flow matrix gives the flow from state \\(i\\) to state \\(j\\). The default inflow and outflow vectors can therefore be computed as the column sums and row sums respectively. Continuing the SI model example, we have the following flow matrix. \\[ \\mathbf{F} = \\begin{bmatrix} 0 &amp; \\frac{\\beta I}{N}S &amp; 0 \\\\ 0 &amp; 0 &amp; \\gamma I \\\\ 0 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] There are times however where one wants a particular flow from one state to another to include only the inflow component and not the outflow. For example in cases where death removes individuals from the population. We consider this and other examples of asymmetric flow in later chapters (TODO). 3.3 Rate Matrix In modelling it is often more convenient to define per-capita rates of flow between compartments rather than total flow. The rate matrix, \\(\\mathbf{M}\\), contains these per-capita rates. The elements, \\(F_{ij}\\), of the flow matrix can be computed from the rate matrix and the state vector as follows. \\[ F_{ij} = M_{ij}s_i \\] The rate matrix for the SI model is given by the following expression. \\[ \\mathbf{M} = \\begin{bmatrix} 0 &amp; \\frac{\\beta I}{N} &amp; 0 \\\\ 0 &amp; 0 &amp; \\gamma \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix} \\] The elements of the rate matrix are determined by expressions involving elements of the state vector and parameters, which we collect into a paramter vector, \\(\\mathbf{\\theta}\\). For the SI model \\(\\mathbf{\\theta}\\) contains two parameters. \\[ \\mathbf{\\theta} = \\begin{bmatrix} \\beta \\\\ \\gamma \\\\ N \\end{bmatrix} \\] 3.4 Rate Matrix Dependence on State Variables and Parameters Currently it is not possible to specify elements of the rate matrix as arbitrary arithmetic expressions involving state variables and parameters – although we plan to add this functionality. However, there is a reasonable degree of flexibility. Each element of the rate matrix can be any expression that obeys the following rules. Any element, \\(x\\), of either the parameter or state vector can be used to define a factor in one of the following three forms. Identity: \\(x\\) Complement: \\(1-x\\) Inverse: \\(1/x\\) We collect these user-defined factors into a factor vector, \\(\\mathbf{y}\\). Factors can be repeated in \\(\\mathbf{y}\\) if required. Any number of factors can be multiplied together using * to produce a product. Any number of factors and products can be added together using +. There is the following higher level nested structure associated with the factor vector, \\(\\mathbf{y}\\). All factors associated with the, \\(i\\)th, non-zero rate matrix element, \\(M_{(i)}\\), are grouped together in a contiguous block within \\(\\mathbf{y}\\) Within the \\(i\\)th block, all factors associated with the \\(j\\)th product (\\(j = 1 ... n_i\\)) in that block are grouped together in a contiguous sub-block Within the \\(i,j\\)th sub-block, all factors are given an index, \\(k = 1 ... m_{ij}\\) With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression. \\[ M_{(i)} = \\sum_{j=1}^{n_i} \\prod_{k=1}^{m_{ij}} y_{ijk} \\] where \\(y_{ijk}\\) is the \\(k\\)th factor associated with the \\(j\\)th product associated with the \\(i\\)th non-zero rate matrix element. from to n-fctrs n-prdcts n-vrbls state-dependent time-varying sum-dependent S I 3 1 3 TRUE FALSE FALSE I R 1 1 1 FALSE FALSE FALSE McMasterPandemic is designed to be modular allow multiple definitions of valid expressions for the rate matrix. In later chapters we describe this possibility (TODO). 3.5 Next Steps "],["simulation.html", "4 Simulation", " 4 Simulation All previous chapters were concerned with defining a compartmental model. In this chapter we switch to getting results from a defined model. Once a model object is defined, it can be used to generate simulations using the simulation_history function. simulation_history(sir) The output contains a column for the simulation date, one column for each state variable (S, I and R in this case), and one column for every time-varying rate (S_to_I). The names of the time-varying rates are always of the form {from_state}_to_{to_state}. The reason why S_to_I is time-varying in this model is that it depends on a state variable, I, which is itself varying at every time-step. The rate_summary function can be used to remind us of this fact. (sir %&gt;% rate_summary(include_formula = TRUE) %&gt;% select(from, to, formula) ) ## from to formula ## S_to_I S I (I) * (beta) * (1/N) ## I_to_R I R (gamma) We see here that S_to_I does indeed depend on I in its formula, whereas I_to_R depends only on a parameter, gamma. Note that the above command uses the tidyverse-style pipe, %&gt;%, operator and another tidyverse function, select. This illustrates a general philosophy of McMasterPandemic, which is that we try to make the outputs plug into other existing and popular tools rather than reinvent existing functionality for a narrower purpose. For example, the rate_summary function returns a data frame that can be manipulated by other data frame manipulation tools. We can plug into other existing and popular tools to make a plot of the simulated epidemic trajectory. (sir %&gt;% simulation_history %&gt;% select(-S_to_I) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Population&quot;) %&gt;% mutate(State = factor(State, levels = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;))) %&gt;% ggplot + geom_line(aes(Date, Population, colour = State)) ) There are a few places you can go from here: Learn how to fit a model to observed data through Calibration Learn how to modify the values of parameters in simulation time using Time Varying Parameters "],["calibration.html", "5 Calibration 5.1 Loss Functions", " 5 Calibration Sometimes it is possible to obtain observed time-series data from an epidemic that one is modelling. It is natural to want to use such data to refine parameter values. This process of refinement is called calibration. To illustrate McMasterPandemic calibration functionality, we are going to calibrate to a synthetic dataset generated by the model we are calibrating. In the last chapter we showed how to simulate from a simple SIR model. Here we simulate from this model and then manipulate the resulting data into a form that could be used for calibration. Although this functionality can be used to fit any number of model parameters to any number of observed time-series, here we generate a single time-series of the numbers of infected individuals. synthetic_data = (sir %&gt;% simulation_history(include_initial_date = FALSE) %&gt;% select(Date, I) %&gt;% pivot_longer(-Date, names_to = &quot;var&quot;, values_to = &quot;value&quot;) %&gt;% rename(date = Date) ) When fitting data to a model a specific format must be used. In particular there must be exactly the following three columns. date – date associated with each observation var – name of the state variable to compare value – observed value to compare with the simulated state variable In this particular case there is only a single state variable used, but this need not be the case. We next update the model object so that it contains two new ingredients: (1) the observed time-series data and (2) information on what parameters to fit and how to fit them. sir_to_calibrate = (sir %&gt;% update_observed(synthetic_data) %&gt;% update_opt_params( log_beta ~ log_flat(0), log_nb_disp_I ~ log_normal(0, 5) ) ) The observed time-series data are simply added via the update_observed function. The information of what parameters to fit gets passed to update_opt_params. This information is provided using two-sided formulas for each parameter to be optimized. The information on what parameter to optimize appears on the left-hand-side of the formula (i.e. to the left of the tilde). Here we optimize the transmission rate parameter, beta, because the numbers of infected individuals in our time-series will be most informative about this parameter. The prefix log_ is used to indicate that the parameter should get passed to the objective function on the log scale. This transformation is useful because it keeps the transmission rate positive. If no transformation is desired, then simply beta should appear on the left-hand-side. The following additional transformations are available: logit_, log10, cloglog_, inverse_. The information on what prior distribution (or regularization function) to use, as well as initial values for the optimizer, are provided on the right-hand-side of the formula. Currently, the transformation (i.e. log_ in this case) must match the left-hand-side, although we plan to remove this restriction so that the scale on which the prior density is evaluated can be different from the scale on which the parameter is passed to the objective function. There are only two prior distributions available currently: flat and normal. The flat prior is an improper flat distribution, providing no regularization. The only hyperparameter to the flat prior is the initial value for the optimizer on the transformed scale. The normal prior is the normal distribution with two hyperparameters, mean and standard deviation. The mean is also taken as the starting value. Note that there is another parameter that we need to describe that we did not include in our original definition of the model: nb_disp_I. This is the dispersion parameter of the negative binomial distribution used to model errors in the fit of the data to the simulated trajectories. We have used a log_normal prior here instead of a log_flat prior, because negative binomial dispersion parameters have a tendency to get very large in synthetic data cases like this where there is very little error – large dispersion parameters indicate consistency with Poisson error. This negative binomial parameter has been added automatically to the params element of the model when the observed data are added. sir_to_calibrate$params ## beta gamma N nb_disp_I ## 1e-01 1e-02 1e+02 1e+00 But note how the parameters in the original model did not contain this parameter. sir$params ## beta gamma N ## 1e-01 1e-02 1e+02 The sir_to_calibrate object can be calibrated using one of the optimizers in R that have been wrapped for use with flexmodels. There are currently two options: nlminb_flexmodel and optim_flexmodel. The difference between the two is that the former uses second-derivative information whereas the latter does not; they both use first-derivative information. sir_calibrated = nlminb_flexmodel(sir_to_calibrate) ## Constructing atomic D_lgamma ## outer mgc: 64.34046 ## Constructing atomic D_lgamma ## outer mgc: 48.12454 ## outer mgc: 263.9845 ## outer mgc: 422.1959 ## outer mgc: 349.1833 ## outer mgc: 56.51855 ## outer mgc: 27.31117 ## outer mgc: 5.80283 ## outer mgc: 1.992753 ## outer mgc: 0.6344536 ## outer mgc: 0.1558516 ## outer mgc: 0.01837424 ## outer mgc: 0.0003485235 ## outer mgc: 1.31046e-07 The result of these optimization functions is another model object, containing the following additional element. sir_calibrated$opt_obj ## $par ## log_beta log_nb_disp_I ## -2.302585 9.366319 ## ## $objective ## [1] 677.25 ## ## $convergence ## [1] 0 ## ## $iterations ## [1] 14 ## ## $evaluations ## function gradient ## 19 14 ## ## $message ## [1] &quot;relative convergence (4)&quot; This element is the object returned by the wrapped optimizer (nlminb in this case) – it can provide useful information about how well the optimization worked. In this case we see convergence, but this need not be true. Refer to documentation for nlminb and optim for help on interpreting these outputs. We can now look at the parameter vector, which has been updated to reflect the calibration. sir_calibrated$params ## beta gamma N nb_disp_I ## 0.10 0.01 100.00 11688.01 ## attr(,&quot;tv_param_indices&quot;) ## named integer(0) Fitted flexmodel objects have a fitted method that can be used to compare the fits with the observed values. (sir_calibrated %&gt;% fitted %&gt;% ggplot() + geom_point(aes(date, value)) + geom_line(aes(date, value_fitted), colour = &#39;red&#39;) ) As expected, the fit is exact because the model that was fitted was also used to simulate the data. 5.1 Loss Functions Let \\(l_{\\psi_i}\\left(x_i(\\theta); y_i\\right)\\) be a loss function where \\(x_i(\\theta)\\) is a simulated element of the history matrix, \\(y_i\\) is an associated observed data point, and \\(\\psi_i\\) is a vector of loss function parameters. Note that we write the simulation values as functions of \\(\\theta\\) to indicate their dependence on parameters. Every element \\(i\\) that belongs to the same column of the history matrix has the same value for \\(\\psi_i\\), but to simplify notation \\(\\psi\\) is sub-scripted by \\(i\\). Let \\(r_{\\phi_j}(\\theta_j)\\) be an optional regularization function for each parameter \\(\\theta_j\\) being optimized, where \\(\\phi_j\\) is a vector of regularization function parameters associated with parameter \\(j\\). The objective function is then given by the following. \\[ L_{\\psi, \\phi}(\\theta; y) = \\sum_i l_{\\psi_i}\\left(x_i(\\theta); y_i\\right) + \\sum_j r_{\\phi_j}(\\theta_j) \\] Currently the only objective function that is offered is the negative log negative binomial density, but the infrastructure we build assumes that other loss functions will be allowed in the future. Similarly the only regularizing function that is available is the negative log normal density. Each parameter, \\(\\theta_j\\), can be optionally passed into the objective function on a transformed scale. These transformations allow users to enforce limits on the domain of the parameter space (e.g. a logit transformation will keep parameter values between 0 and 1). The regularization functions are applied on the transformed scale, but the elements of the rate matrix (and therefore the simulations, \\(x\\)) are computed using the parameters on their original scale. Therefore, we have the following ordering of operations. Parameter, \\(\\theta_j\\), is passed in to the objective function on the transformed scale, \\(f(\\theta_j)\\) The regularization function, \\(r_{\\phi_j}(\\theta_j)\\), is computed and saved The inverse transformation is applied to the parameter, \\(\\theta_j\\), and the result is used to overwrite the previous value in the c++ params vector The simulations are made The objective function, \\(L\\), is computed, and this computation includes adding the saved values of the regularization functions The objective function, \\(L\\), is returned by the c++ function objective_function 5.1.1 Negative Binomial \\[ \\frac{\\Gamma(x+k)}{\\Gamma(k) x!} \\left(\\frac{k}{k + \\mu}\\right)^k \\left(\\frac{\\mu}{k + \\mu}\\right)^x \\] \\[ \\log\\Gamma(x+k) - \\log\\Gamma(k) - \\log(x!) + k \\log\\left(\\frac{k}{k + \\mu}\\right) + x\\log\\left(\\frac{\\mu}{k + \\mu}\\right) \\] "],["time-varying-parameters.html", "6 Time Varying Parameters 6.1 Example of Time-Variation 6.2 Calibrating Time-Variation Schedules", " 6 Time Varying Parameters Any parameter in a McMasterPandemic model can be scheduled to vary in time. A time-variation schedule is a data frame with one row for each date on which each parameter changes its value. This data frame has four columns: Date – Date on which a particular parameter changes its value Symbol – String giving the symbol representing the changing parameter Value – The numeric value used to change the value of the parameter, the effect of which depends on the value of the Type column Type – One of the following strings: \"abs\" – The Value column is the new value for the parameter on Date \"rel_orig\" – The Value column is multiplied by the original value of the changing parameter at the beginning of the simulation, to generate a new value for the parameter on Date \"rel_prev\" – The Value column is multiplied by the previous value of the changing parameter, to generate a new value for the parameter on Date Once a time-variation data frame is produced it can get added to a model when it is created via the params_timevar argument of flexmodel, or by updating an existing flexmodel object using the update_piece_wise function. 6.1 Example of Time-Variation In this example we create a time-variation schedule that causes the transmission, beta, drop to very low levels on May 15. random_timevar = data.frame( Date = ymd(20200515), Symbol = &#39;beta&#39;, Value = 0.01, Type = &#39;abs&#39; ) random_timevar ## Date Symbol Value Type ## 1 2020-05-15 beta 0.01 abs sir_with_timevar = (sir %&gt;% update_piece_wise(random_timevar) ) timevar_sims = (sir_with_timevar %&gt;% simulation_history(include_initial_date = FALSE) %&gt;% tidyr::pivot_longer(-Date, names_to = &quot;var&quot;) %&gt;% rename(date = Date) %&gt;% mutate(value = round(value)) %&gt;% filter(var %in% c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;)) ) (ggplot(timevar_sims) + geom_line(aes(date, value, colour = var)) ) Notice the abrupt break-point on May 15. See The SIRV model and Covid SEIR for other examples of the use of time-varying parameters in simulation models. 6.2 Calibrating Time-Variation Schedules Entries in the Value column can be NA, indicating that these should be fitted using Calibration. When flagging time-variation values for calibration in this way, one must also provide information on any parameter transformations and prior distributions. Do provide this information, we use a technique similar to the one described in the Calibration chapter to specify transformations and prior distributions for parameters in the params element of flexmodel objects. In that chapter we used the add_opt_params function – here we use the add_opt_tv_params function (the tv stands for time-variation). To illustrate calibration of time-variation values, we mark for calibration the break-point on May 15 in our example above. calibrate_timevar = (random_timevar %&gt;% mutate(Value = NA) ) Then we update our model with the sir_with_timevar simulations to fit to, and specify how to optimize the parameters. sir_to_cal_tv = (sir_with_timevar %&gt;% update_observed(timevar_sims) %&gt;% update_piece_wise(calibrate_timevar) %&gt;% add_opt_params(log_beta ~ log_flat(0) , log_nb_disp_S ~ log_normal(0, 1) , log_nb_disp_I ~ log_normal(0, 1) , log_nb_disp_R ~ log_normal(0, 1) ) %&gt;% add_opt_tv_params(tv_type = &quot;abs&quot; , log_beta ~ log_flat(0) ) ) The key function here is add_opt_tv_params, which allows us to specify a flat prior on the log scale for fitting the time-variation values. It turns out that in this case we need to make one technical adjustment – see Simulated time-series close to zero for an explanation. sir_to_cal_tv$do_sim_constraint = TRUE With this sir_to_cal_tv object we can now fit this model to the simulated data. sir_cal_tv = nlminb_flexmodel(sir_to_cal_tv) ## outer mgc: 141602.9 ## outer mgc: 323.4935 ## outer mgc: 865.305 ## outer mgc: 1116.945 ## outer mgc: 315.6958 ## outer mgc: 1271.766 ## outer mgc: 613.5591 ## outer mgc: 1285.651 ## outer mgc: 2337.036 ## outer mgc: 2582.829 ## outer mgc: 1173.873 ## outer mgc: 283.9274 ## outer mgc: 6153.751 ## outer mgc: 1189.738 ## outer mgc: 253.1351 ## outer mgc: 122.3245 ## outer mgc: 5804.288 ## outer mgc: 4626.501 ## outer mgc: 1124.72 ## outer mgc: 546.7969 ## outer mgc: 4.882029 ## outer mgc: 0.5063119 ## outer mgc: 0.01292487 ## outer mgc: 9.024538e-06 The time-variation values before, during, and after optimization look as we would expect, given that we fitted to the same model that generated the data. c( before = sir_with_timevar$timevar$piece_wise$schedule$Value, during = sir_to_cal_tv$timevar$piece_wise$schedule$Value, after = sir_cal_tv$timevar$piece_wise$schedule$Value ) ## before during after ## 0.010000000 NA 0.009945231 "],["other-variables.html", "7 Other Variables 7.1 Intermediate Results 7.2 Additional Variables in the Simulation History", " 7 Other Variables So far the only types of variables that we have discussed are parameters and state variables. In this chapter we cover all of the other kinds of variables. There are two basic kinds of other variables: (1) Intermediate Results and (2) Additional Variables in the Simulation History. The main difference between the two types is that the former can be used for more purposes than the latter. In particular, intermediate results can be used in expressions that define rate matrices whereas additional variables in the simulation history cannot. Conversely, all intermediate results get added to the simulation history. 7.1 Intermediate Results Sometimes the expression giving the rate of flow between two compartments is quite complex, or even just impossible to express in terms of just parameters and state variables given the restrictions described in the chapter on [Flows Between States]. In these cases, it is often convenient or even necessary to store intermediate combinations of parameters and state variables and then use these combinations in subsequent expressions for flow rates. There are two basic kinds of intermediate results: (1) sums of state variables and parameters and (2) more general expressions, called factrs, that combine state variables, parameters, and their sums. 7.1.1 Sums of State Variables and Parameters One may save any sum of state variables and/or parameters to the model. In our SIR model for example, we specified the total population size in the parameter vector as N. However, we could compute this population size using the add_state_param_sum function. sir = (flexmodel( params = c(beta = 0.1, gamma = 0.01), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) %&gt;% add_state_param_sum(&quot;N&quot;, &quot;S|I|R&quot;) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) The first argument to the add_state_param_sum is just a name for the sum. Note that this name is used in the add_rate function that defines the flows from S to I. The second argument to the add_state_param_sum is a regular expression that is matched agains all parameter names and state variable names. Here we match any state variable with \"S|I|R\", which tells McMasterPandemic to add up all state variables and save the result in the variable called \"N\". See the Erlang SEIR example that uses a sum to save the total number of infected individuals across all I compartments in an Erlang-chain. See the BC Covid Omicron example that uses a sum to save the total number of individuals infected with different COVID strains. 7.1.2 Factrs First off, I’m sorry about the name factr. It is not a typo, I just don’t have the energy to change it to something better right now. factrs are simply a saved expression that follows the same rules for rates of [Flows Between States]. These factrs are named and can subsequently be used in rate expressions. The SIR model is not really complex enough to justify using factrs, but if we wanted to we could store the proportion of individuals that are in the I box as a factr and then use that factr in the expression for the rate from S to I. sir = (flexmodel( params = c(beta = 0.1, gamma = 0.01), state = c(S = 99, I = 1, R = 0), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) %&gt;% add_state_param_sum(&quot;N&quot;, &quot;S|I|R&quot;) %&gt;% add_factr(&quot;Iprop&quot;, ~ (I) * (1/N)) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (Iprop) * (beta)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) See also the SI model example for a use of factrs that computes the equilibrium populations in each compartment. 7.2 Additional Variables in the Simulation History The simulation_history function returns a data frame containing many of the variables in the model, with each row giving each time step in the simulation. This simulation_history function is introduced in the chapter on Simulation. This simulation history table is used for two purposes: (1) to return to the user as simulation output and (2) to compare with observed time series in in the process of Calibration. The simulation history contains the following variables in the following order: State variables Flow rates that vary in simulation time (constant rates are omitted) Sums of state variables and parameters factrs Expressions following the rules in [Flows Between States] of any of the variables in 1-4 above Lagged differenced versions of 1-5 Convolutions of 1-5 Items 5-7 consitute the additional variables in the simulation history. In the next sections we illustrate how to add such variables to the SIR model. 7.2.1 Simulation History Expressions TODO: describe add_sim_report_expr function 7.2.2 Lagged Differencing TODO: describe add_lag_diff function 7.2.3 Convolutions TODO: describe add_conv function "],["ensemble-forecasts.html", "8 Ensemble Forecasts", " 8 Ensemble Forecasts Good forecasts include measures of uncertainty associated with each forecasted data point. The simulate_ensemble function allows one to make such forecasts. "],["vectors.html", "9 Vectors", " 9 Vectors Throughout most of our discussions we have used a simple SIR model as an example. However, many real-world applications involve some kind of compartment structure. For example, the McMaster COVID modelling team used a model with vaccination structure where each epidemiological status (e.g. S, E, I, R) requires five compartments. Each of these five compartments represents a different vaccination status: unvaccinated, received first dose, protected by first dose, receieved second dose, protected by second dose. There are many other examples of model structure that multiply the numbers of compartments including age, variants, and space. As base epidemiological compartments are multiplied with structure, the scalar valued parameters, states, and rates become vectors and matrices. (TODO: describe matrix-formulations of the force of infection under structure). McMasterPandemic provides struc objects for doing symbolic matrix algebra that allows one to specify vector-valued rates to multiple flows at the same time (e.g. force of infection for every vaccination status). The scal, vec, and mat functions can be used to construct scalar-valued, vector-valued, and matrix-valued struc objects. A very simple example of struc objects is given by this Two-Strain SIR model. "],["hazard-smoothing.html", "10 Hazard Smoothing", " 10 Hazard Smoothing "],["state-initialization.html", "11 State Initialization", " 11 State Initialization "],["outflows.html", "12 Outflows 12.1 Accumulators", " 12 Outflows In compartmental modelling we typically want to balance each flow out of a boxes with an equal flow into another box. This is because individuals are simply changing their epidemiological status as they move between boxes, and the total number of individuals across the boxes remains constant. McMasterPandemic assumes this standard balance between inflows and outflows by default. This default makes it very easy to enforce inflow-outflow balance. This ease of use contrasts with the standard practice of writing down difference or differential equations to define the model (e.g. POMP, STAN). This equation-style interface requires that the user make sure each inflow term in one equation is appropriately balanced by an outflow term in another equation. In McMasterPandemic you define the inflows, and by default it automatically creates balancing outflows. 12.1 Accumulators It is sometimes necessary to override this default inflow-outflow balance. One use-case that requires something other than the default is in the definition of an accumulator compartment, which allows one to track the cumulative number of individuals that have ever entered a particular compartment or set of compartments. For example, suppose that we want to keep track of the total number of individuals who have ever been infected in our SIR model. To do this we define an X accumulator compartment. This X box has the same inflow from S as does I, but we restrict outflow from S as individuals flow in to X – otherwise we would double-count the draining of S. We specify this custom outflow model with the add_outflow function. sir_with_accumulator = (init_model( params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, I = 1, R = 0, X = 1), start_date = &quot;2020-03-11&quot;, end_date = &quot;2020-12-01&quot; ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;S&quot;, &quot;X&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) %&gt;% add_outflow(from = &quot;S|I&quot;, to = &quot;I|R&quot;) ) ## Warning in init_model(params = c(beta = 0.1, gamma = 0.01, N = 100), state = c(S = 99, : ## init_model is deprecated. ## please use flexmodel. ## the only difference between the two functions is the name. The add_outflow function here takes two regular expressions, from and to. The first from regular expression matches states that individuals must flow out of, only if the flow is to states matched by the second to regular expression. (sir_with_accumulator %&gt;% simulation_history %&gt;% select(-S_to_I, -S_to_X) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Population&quot;) %&gt;% ggplot() + geom_line(aes(Date, Population, colour = State)) ) Note how sometime in July almost everyone has been infected at some point in the epidemic. "],["examples.html", "13 Examples 13.1 Hello World: Simulating an SIR Model 13.2 SI 13.3 SEIR 13.4 Structure: Two-Strain SIR 13.5 Erlang SEIR 13.6 The SIRV model 13.7 Variolation model 13.8 SEIRD Model 13.9 Covid SEIR 13.10 BC Covid Omicron 13.11 Classic McMasterPandemic", " 13 Examples library(dplyr) library(tidyr) library(lubridate) 13.1 Hello World: Simulating an SIR Model state = c(S = 20000, I = 100, R = 0) sir_model = ( flexmodel( params = c( gamma = 0.06, beta = 0.15, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (1/N) * (beta) * (I)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) sir_model ## from to n_fctrs n_prdcts n_vrbls state_dependent time_varying ## S_to_I S I 3 1 3 TRUE FALSE ## I_to_R I R 1 1 1 FALSE FALSE ## sum_dependent ## S_to_I FALSE ## I_to_R FALSE (sir_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) (sir_model %&gt;% simulate_changing_ratemat_elements(add_dates = TRUE) %&gt;% rename(`force of infection` = S_to_I) %&gt;% ggplot + geom_line(aes(x = Date, y = `force of infection`)) ) 13.2 SI si = (flexmodel( params = c(beta = 0.15, gamma = 0.06, N = 100), state = c(S = 99, I = 1), start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-06-01&quot; ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (I) * (beta) * (1/N)) %&gt;% add_rate(&quot;I&quot;, &quot;S&quot;, ~ (gamma)) %&gt;% add_factr(&quot;ratio&quot;, ~ (gamma) * (1/beta)) %&gt;% add_factr(&quot;S_hat&quot;, ~ (N) * (ratio)) %&gt;% add_factr(&quot;I_hat&quot;, ~ (N) * (1 - ratio)) ) (si %&gt;% simulation_history %&gt;% select(-S_to_I, -ratio) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Population&quot;) %&gt;% separate(State, c(&quot;State&quot;, &quot;Equilibrium&quot;), &quot;_&quot;) %&gt;% mutate(Equilibrium = ifelse(is.na(Equilibrium), &#39;no&#39;, &#39;yes&#39;)) %&gt;% ggplot + geom_line(aes(Date, Population, colour = State, linetype = Equilibrium)) ) ## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 306 rows [1, 2, ## 5, 6, 9, 10, 13, 14, 17, 18, 21, 22, 25, 26, 29, 30, 33, 34, 37, 38, ...]. 13.3 SEIR state = c(S = 20000, E = 0, I = 100, R = 0) seir_model = ( flexmodel( params = c( alpha = 0.05, gamma = 0.06, beta = 0.15, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE, ) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (1/N) * (beta) * (I)) %&gt;% add_rate(&quot;E&quot;, &quot;I&quot;, ~ (alpha)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) seir_model ## from to n_fctrs n_prdcts n_vrbls state_dependent time_varying ## S_to_E S E 3 1 3 TRUE FALSE ## E_to_I E I 1 1 1 FALSE FALSE ## I_to_R I R 1 1 1 FALSE FALSE ## sum_dependent ## S_to_E FALSE ## E_to_I FALSE ## I_to_R FALSE 13.4 Structure: Two-Strain SIR strains = c(&quot;wild&quot;, &quot;variant&quot;) state = c( S = 20000, I_wild = 49, I_variant = 1, R_wild = 0, R_variant = 0 ) two_strain_model = ( flexmodel( params = c( gamma = 0.06, beta_wild = 0.15, beta_variant = 0.25, N = sum(state) ), state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-05-01&quot;, do_hazard = TRUE ) %&gt;% vec_rate( &quot;S&quot;, &quot;I&quot; %_% strains, vec(&quot;beta&quot; %_% strains) * struc(&quot;1/N&quot;) * vec(&quot;I&quot; %_% strains) ) %&gt;% rep_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) ) regex = &quot;^(S|I|R)(_*)(.*)&quot; (two_strain_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value) %&gt;% mutate(strain = sub(pattern = regex, replacement = &quot;\\\\3&quot;, name)) %&gt;% mutate(epi_cat = sub(pattern = regex, replacement = &quot;\\\\1&quot;, name)) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat, linetype = strain)) ) (two_strain_model %&gt;% simulate_changing_ratemat_elements(add_dates = TRUE) %&gt;% pivot_longer(starts_with(&quot;S_to_I&quot;)) %&gt;% mutate(name = sub(&quot;S_to_I_&quot;, &quot;&quot;, name)) %&gt;% rename(`force of infection` = value) %&gt;% rename(strain = name) %&gt;% ggplot + geom_line(aes(x = Date, y = `force of infection`, colour = strain)) ) 13.5 Erlang SEIR David, Jonathan, and David describe the Erlang SEIR model in continuous time. Here is a discrete time version of it. n = 4 # number of I states m = 6 # number of E states erlang_seir = (flexmodel( # FIXME: only working for no demography (so mu = 0 for now) params = c(mu = 0, beta = 1.5, m = m, n = n, gamma = 1.2, sigma = 0.1), state = c( S = 1-1e-3, layered_zero_state(&quot;E&quot; %_% 1:m), I_1 = 1e-3, layered_zero_state(&quot;I&quot; %_% 2:n), R = 0, D = 0, . = 1), start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-04-01&quot;, do_hazard = TRUE ) %&gt;% add_state_param_sum(&quot;I&quot;, &quot;^I_[0-9]+&quot;) # birth %&gt;% add_rate(&quot;.&quot;, &quot;S&quot;, ~ (mu)) # death %&gt;% rep_rate( from = c(&quot;S&quot;, &quot;E&quot; %_% 1:m, &quot;I&quot; %_% 1:n, &quot;R&quot;), to = &quot;D&quot;, formula = ~ (mu)) # infection %&gt;% add_rate(&quot;S&quot;, &quot;E_1&quot;, ~ (beta) * (I)) # become infectious %&gt;% add_rate(&quot;E&quot; %_% m, &quot;I_1&quot;, ~ (m) * (sigma)) # sojourn through exposed compartments %&gt;% rep_rate( &quot;E&quot; %_% 1:(m-1), &quot;E&quot; %_% 2:m, ~ (m) * (sigma) ) # sojourn through infectious compartments %&gt;% rep_rate( &quot;I&quot; %_% 1:(n-1), &quot;I&quot; %_% 2:n, ~ (n) * (gamma) ) # recovery %&gt;% add_rate(&quot;I&quot; %_% n, &quot;R&quot;, ~ (n) * (gamma)) # nothing flows out of . because it is a dummy # state used to generate flows that are not per-capita %&gt;% add_outflow(&quot;[^.]&quot;) ) (erlang_seir %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% select(-., -D) %&gt;% pivot_longer(-Date, names_to = &quot;State&quot;, values_to = &quot;Count&quot;) %&gt;% mutate(State = sub(&quot;_[0-9]+&quot;, &quot;&quot;, State)) %&gt;% group_by(Date, State) %&gt;% summarise(Count = sum(Count)) %&gt;% ungroup %&gt;% ggplot() + geom_line(aes(Date, Count, colour = State)) ) ## `summarise()` has grouped output by &#39;Date&#39;. You can override using the ## `.groups` argument. # check to make sure that the population density # remains constant at one (erlang_seir %&gt;% simulate_state_vector(add_dates = FALSE) %&gt;% select(-., -D) %&gt;% rowSums %&gt;% sapply(all.equal, 1L) %&gt;% sapply(isTRUE) %&gt;% all ) ## [1] TRUE 13.6 The SIRV model state = c(S = 20000, I = 100, R = 0, V = 0) params = c( gamma = 0.06, beta = 0.15, v = 0, # initial vaccination rate N = sum(state) ) # roll out the vaccine by bumping the # vaccination rate twice params_timevar = data.frame( Date = c(&quot;2020-02-01&quot;, &quot;2020-03-01&quot;), Symbol = c(&quot;v&quot;, &quot;v&quot;), Value = c(0.01, 0.1), Type = c(&quot;abs&quot;, &quot;abs&quot;)) sirv_model = ( flexmodel( params = params, state = state, params_timevar = params_timevar, start_date = &quot;2020-01-01&quot;, end_date = &quot;2020-05-01&quot;, do_hazard = TRUE ) %&gt;% add_rate(&quot;S&quot;, &quot;I&quot;, ~ (beta) * (1/N) * (I)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (gamma)) %&gt;% add_rate(&quot;S&quot;, &quot;V&quot;, ~ (v)) ) (sirv_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) + geom_vline(aes(xintercept = as.Date(Date)), data = params_timevar, colour = &#39;lightgrey&#39;) ) 13.7 Variolation model state = c( S = 20000, I_severe = 50, I_mild = 50, R_mild = 0, R_severe = 0 ) params = c( nu = 0.0105, # birth rate mu = 0.0105, # death rate delta = 1/7, # waning immunity rate gamma_mild = 1/(3.3 + 9), # recovery rate of mild cases gamma_severe = 1/(3.3 + 14), # recovery rate of severe cases beta_mild = 0.15, # transmission rate of infections leading to mild cases beta_severe = 0.3, # transmission rate of infections leading to severe cases m = 0.6 # probability of developing mild illness ) # model structure all_states = names(state) severity = c(&quot;mild&quot;, &quot;severe&quot;) beta_vec = vec(&quot;beta&quot; %_% severity) I_vec = vec(&quot;I&quot; %_% severity) foi = kronecker(vec(&quot;m&quot;, &quot;1-m&quot;), sum(beta_vec * I_vec * struc(&quot;1/N&quot;))) variolation_model &lt;- ( flexmodel( params = params, state = state, start_date = &quot;2020-01-01&quot;, end_date = &quot;2020-04-01&quot; ) %&gt;% add_state_param_sum(&quot;N&quot;, any_var(state)) # births and deaths # (FIXME: this only works if nu = mu) %&gt;% rep_rate( all_states, &quot;S&quot;, ~ (nu) ) # infection %&gt;% vec_rate( &quot;S&quot;, &quot;I&quot; %_% severity, foi ) # waning immunity %&gt;% rep_rate( &quot;R&quot; %_% severity, &quot;S&quot;, ~ (delta) ) # recovery %&gt;% vec_rate( &quot;I&quot; %_% severity, &quot;R&quot; %_% severity, vec(&quot;gamma&quot; %_% severity) ) ) (variolation_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) 13.8 SEIRD Model This is the Mac Theo Bio Model. state = c(S = 20000, E = 50, I = 50, R = 0, D = 0, Null = 0) params = c( # transmission rates of susceptibles from live and dead individuals beta_I = 5, beta_D = 2, # average times in various boxes T_E = 10, T_I = 14, T_D = 10, # probability of death given infection f = 0.5 ) seird_model = ( flexmodel( params = params, state = state, start_date = &quot;2000-01-01&quot;, end_date = &quot;2000-03-01&quot;, do_hazard = TRUE ) %&gt;% add_state_param_sum(&quot;N&quot;, any_var(state)) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (beta_I) * (1/N) * (I) + (beta_D) * (1/N) * (D)) %&gt;% add_rate(&quot;E&quot;, &quot;I&quot;, ~ (1/T_E)) %&gt;% add_rate(&quot;I&quot;, &quot;R&quot;, ~ (1/T_I) * (1 - f)) %&gt;% add_rate(&quot;I&quot;, &quot;D&quot;, ~ (1/T_I) * (f)) %&gt;% add_rate(&quot;D&quot;, &quot;Null&quot;, ~ (1/T_D)) ) (seird_model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% rename(state = value, epi_cat = name) %&gt;% ggplot + geom_line(aes(x = Date, y = state, colour = epi_cat)) ) 13.9 Covid SEIR The BC covid modelling group uses this compartmental model for their inference and forecasting work. This model can be expressed in McMasterPandemic with the following. foi = ( vec(c(&quot;1&quot;, &quot;f&quot;)) * struc(&quot;beta&quot;) * struc(&quot;1/N&quot;) * (struc(&quot;(I) + (E2)&quot;) + (struc(&quot;f&quot;) * struc(&quot;(Id) + (E2d)&quot;))) ) params = c( N = 5100000, D = 5, k1 = 0.2, k2 = 1, q = 0.05, ud = 0.1, ur = 0.02, psir = 0.3, shape = 1.73, scale = 9.85, beta = 0.433, f = 1 ) state = c( S = 849999, E1 = 0.53, E2 = 0.13, I = 0.67, Q = 0, R = 0, Sd = 4249993, E1d = 2.67, E2d = 0.67, Id = 3.33, Qd = 0, Rd = 0 ) base_states = names(state)[1:6] dist_states = base_states %+% &quot;d&quot; strats = c(&quot;&quot;, &quot;d&quot;) # distancing strategies ramp_period = seq(from = ymd(20210315), to = ymd(20210322), by = 1) time_ratio = rev((seq_along(ramp_period) - 1) / (length(ramp_period) - 1)) f2 = 0.22 params_timevar = data.frame( Date = ramp_period, Symbol = rep(&quot;f&quot;, length(ramp_period)), Value = f2 + time_ratio * (1 - f2), Type = rep(&quot;abs&quot;, length(ramp_period)) ) model = ( flexmodel( params = params, state = state, start_date = &quot;2021-02-01&quot;, end_date = &quot;2021-06-01&quot;, do_hazard = TRUE, params_timevar = params_timevar ) # flow between distancing strategies %&gt;% rep_rate(base_states, dist_states, ~ (ud)) %&gt;% rep_rate(dist_states, base_states, ~ (ur)) # force of infection %&gt;% vec_rate( &quot;S&quot; %+% strats, &quot;E1&quot; %+% strats, foi ) # flow within distancing strategies %&gt;% rep_rate( &quot;E1&quot; %+% strats, &quot;E2&quot; %+% strats, ~ (k1) ) %&gt;% rep_rate( &quot;E2&quot; %+% strats, &quot;I&quot; %+% strats, ~ (k2) ) %&gt;% rep_rate( &quot;I&quot; %+% strats, &quot;Q&quot; %+% strats, ~ (q) ) %&gt;% rep_rate( expand_names(c(&quot;I&quot;, &quot;Q&quot;), strats, &quot;&quot;), expand_names(c(&quot;R&quot;, &quot;R&quot;), strats, &quot;&quot;), ~ (1/D) ) ) (model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% ggplot() + facet_wrap(~ name, scales = &#39;free&#39;, ncol = 2) + geom_line(aes(Date, value)) ) 13.10 BC Covid Omicron The BC group also developed a model with two strains for the Omicron wave of Covid-19. DISCLAIMER: This is not meant to illustrate a realistic forecast, but rather to illustrate how the basic model structure can be expressed in McMasterPandemic params = c( sigma=1/3, # incubation period (3 days) (to fixed) gamma=1/(5), #recovery rate (fixed) nu =0.007, #vax rate: 0.7% per day (fixed) mu=1/(82*365), # 1/life expectancy (fixed) w1 = 1/(3*365),# waning rate from R to S (fixed) w2 = 1/(3*365), # waning rate from Rv to V (fixed) w3 = 1/(3*365),# waning rate Rw to W (fixed) ve=1, # I think this should be 1. it is not really efficacy ( fixed) beta_r=0.72, #transmission rate (to estimate) (0.35) beta_m=0.8*2.2, #transmission rate (to estimate)(*1.9) epsilon_r = (1-0.8), # % this should be 1-ve epsilon_m = (1-0.6), # % escape capacity #(fixed) b= 0.006, # booster rate (fixed) beff = 0.7, # booster efficacy wf=0.2, # protection for newly recoverd #0.2 N=5e6, E0=5, S0=1-1e-5, c=1 ) # dimensions of model structure vax_states = c(&quot;unvax&quot;, &quot;onedose&quot;, &quot;boost&quot;) variant_states = c(&quot;delta&quot;, &quot;omicron&quot;) epi_states = c(&quot;S&quot;, &quot;E&quot; %_% variant_states, &quot;I&quot; %_% variant_states, &quot;R&quot;) # vectors representing variant model structure I_delta = vec(&quot;I&quot; %_% &quot;delta&quot; %_% vax_states) I_omicron = vec(&quot;I&quot; %_% &quot;omicron&quot; %_% vax_states) E_delta = vec(&quot;E&quot; %_% &quot;delta&quot; %_% vax_states) E_omicron = vec(&quot;E&quot; %_% &quot;omicron&quot; %_% vax_states) # initial state vector state = layered_zero_state(epi_states, vax_states) all_states = names(state) state[] = unname(make_init(params)) print(state) ## S_unvax E_delta_unvax E_omicron_unvax I_delta_unvax ## 9.106607e+05 6.480000e+02 1.748571e+01 1.110857e+03 ## I_omicron_unvax R_unvax S_onedose E_delta_onedose ## 2.997551e+01 1.014000e+05 3.502789e+06 5.924571e+02 ## E_omicron_onedose I_delta_onedose I_omicron_onedose R_onedose ## 1.974857e+01 1.015641e+03 3.385469e+01 3.893760e+05 ## S_boost E_delta_boost E_omicron_boost I_delta_boost ## 1.460132e+05 2.468571e+01 8.228571e-01 4.231837e+01 ## I_omicron_boost R_boost ## 1.410612e+00 1.622400e+04 two_strain_bc = (flexmodel( params = params, state = state, start_date = &quot;2022-01-01&quot;, end_date = &quot;2022-05-01&quot;, do_hazard = TRUE ) # sum over every vax status to get # total numbers in I boxes for each # variant %&gt;% add_state_param_sum(&quot;I_delta&quot;, &quot;I_delta_&quot;) %&gt;% add_state_param_sum(&quot;I_omicron&quot;, &quot;I_omicron_&quot;) # R to S boxes for every vax status # -- waning %&gt;% vec_rate( from = &quot;R&quot; %_% vax_states, to = &quot;S&quot; %_% vax_states, vec(&#39;w1&#39;, &#39;w2&#39;, &#39;w3&#39;) ) # S_delta to E_delta for every vax status # -- delta force of infection %&gt;% vec_rate( from = &quot;S&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;delta&quot; %_% vax_states, struc(&quot;(c) * (beta_r) * (1/N) * (I_delta)&quot;) * vec(&quot;1&quot;, &quot;epsilon_r&quot;, &quot;epsilon_r&quot;) ) # S_omicron to E_omicron for every vax status # -- omicron force of infection %&gt;% vec_rate( from = &quot;S&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;omicron&quot; %_% vax_states, struc(&quot;(c) * (beta_m) * (1/N) * (I_omicron)&quot;) * vec(&quot;1&quot;, &quot;epsilon_m&quot;, &quot;epsilon_m&quot;) ) # R to E_delta for every vax status # -- delta force of infection of recovered individuals %&gt;% rep_rate( from = &quot;R&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;delta&quot; %_% vax_states, ~ (wf) * (epsilon_r) * (c) * (beta_r) * (1/N) * (I_delta) ) # R to E_omicron for every vax status # -- omicron force of infection of recovered individuals %&gt;% rep_rate( from = &quot;R&quot; %_% vax_states, to = &quot;E&quot; %_% &quot;omicron&quot; %_% vax_states, ~ (wf) * (epsilon_m) * (c) * (beta_m) * (1/N) * (I_omicron) ) # E to I for all variant-vax combinations %&gt;% rep_rate( from = &quot;E&quot; %_% expand_names(variant_states, vax_states), to = &quot;I&quot; %_% expand_names(variant_states, vax_states), ~ (sigma) ) # recovery for all variant-vax combinations %&gt;% rep_rate( from = &quot;I&quot; %_% expand_names(variant_states, vax_states), to = &quot;R&quot; %_% rep(vax_states, each = length(variant_states)), ~ (gamma) ) # demographics %&gt;% rep_rate( from = all_states, to = &quot;S_unvax&quot;, ~ (mu) ) # vaccination %&gt;% add_rate(from = &quot;S_unvax&quot;, to = &quot;S_onedose&quot;, ~ (nu) * (ve)) %&gt;% add_rate(from = &quot;S_onedose&quot;, to = &quot;S_boost&quot;, ~ (b) * (ve)) ) category_pattern = &quot;^(S|E|I|R)(_omicron|_delta)?_(unvax|onedose|boost)$&quot; (two_strain_bc %&gt;% simulate_state_vector(add_date = TRUE) %&gt;% pivot_longer(-Date, names_to = &quot;Compartment&quot;, values_to = &quot;State&quot;) %&gt;% mutate(`Epi Status` = sub(category_pattern, &#39;\\\\1\\\\2&#39;, Compartment, perl = TRUE)) %&gt;% mutate(`Vaccination Status` = sub(category_pattern, &#39;\\\\3&#39;, Compartment, perl = TRUE)) %&gt;% arrange(`Epi Status`, `Vaccination Status`) %&gt;% mutate(Compartment = factor(Compartment, all_states)) %&gt;% ggplot() + facet_wrap( ~ Compartment, ncol = 3, scales = &#39;free&#39;, dir = &#39;v&#39;) + geom_line(aes(Date, State)) ) 13.11 Classic McMasterPandemic params = read_params(&quot;ICU1.csv&quot;) model = (flexmodel( params = params, state = make_state(params = params)[-14], # -14 removes V compartment start_date = &quot;2020-03-10&quot;, end_date = &quot;2020-12-10&quot;, do_make_state = FALSE, do_hazard = TRUE ) %&gt;% add_rate(&quot;E&quot;, &quot;Ia&quot;, ~ (alpha) * (sigma)) %&gt;% add_rate(&quot;E&quot;, &quot;Ip&quot;, ~ (1 - alpha) * (sigma)) %&gt;% add_rate(&quot;Ia&quot;, &quot;R&quot;, ~ (gamma_a)) %&gt;% add_rate(&quot;Ip&quot;, &quot;Im&quot;, ~ (mu) * (gamma_p)) %&gt;% add_rate(&quot;Ip&quot;, &quot;Is&quot;, ~ (1 - mu) * (gamma_p)) %&gt;% add_rate(&quot;Im&quot;, &quot;R&quot;, ~ (gamma_m)) %&gt;% add_rate(&quot;Is&quot;, &quot;H&quot;, ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;ICUs&quot;, ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;ICUd&quot;, ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s)) %&gt;% add_rate(&quot;Is&quot;, &quot;D&quot;, ~ (nonhosp_mort) * (gamma_s)) %&gt;% add_rate(&quot;ICUs&quot;, &quot;H2&quot;, ~ (psi1)) %&gt;% add_rate(&quot;ICUd&quot;, &quot;D&quot;, ~ (psi2)) %&gt;% add_rate(&quot;H2&quot;, &quot;R&quot;, ~ (psi3)) %&gt;% add_rate(&quot;H&quot;, &quot;R&quot;, ~ (rho)) %&gt;% add_rate(&quot;Is&quot;, &quot;X&quot;, ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)) %&gt;% add_rate(&quot;S&quot;, &quot;E&quot;, ~ (Ia) * (beta0) * (1 / N) * (Ca) + (Ip) * (beta0) * (1 / N) * (Cp) + (Im) * (beta0) * (1 / N) * (Cm) * (1 - iso_m) + (Is) * (beta0) * (1 / N) * (Cs) * (1 - iso_s)) %&gt;% add_outflow(&quot;.+&quot;, &quot;^(S|E|I|H|ICU|D|R)&quot;) ) (model %&gt;% simulate_state_vector(add_dates = TRUE) %&gt;% pivot_longer(!Date) %&gt;% ggplot() + facet_wrap(~ name, scales = &#39;free&#39;, ncol = 3) + geom_line(aes(Date, value)) ) "],["troubleshooting.html", "14 Troubleshooting 14.1 NaN-Valued Objective Function", " 14 Troubleshooting 14.1 NaN-Valued Objective Function 14.1.1 Simulated time-series close to zero When the simulated values that are being compared with data are close to zero (e.g. less than 1e-12), the negative binomial loss function often returns NaN. This can be fixed by setting do_sim_constraint = TRUE as an argument to flexmodel or whatever model constructor is being used (e.g. make_vaccination_model). This flag causes the simulated values to pass through the following soft-thresholding function to keep the simulations, \\(x\\), from falling below a tolerance, \\(\\epsilon\\). \\[ x + \\frac{\\epsilon}{1-(x-\\epsilon)/\\epsilon + (x-\\epsilon)^2/\\epsilon^2} \\] This tolerance can be adjusted by setting the sim_lower_bound = 1e-12. Note that both do_sim_constraint and sim_lower_bound can be set using the global options MP_default_do_sim_constraint and MP_default_sim_lower_bound. 14.1.2 Negative rate matrix elements These can arise naturally due to time-varying parameters that appear in 1-x terms in rate formulas. The best way to avoid this is to use the abs type of time-variation, so that logit transformations can be used directly on the changing parameters. This approach ensures that the parameter never leaves the interval between zero and one. In the future we should have a time-variation option that updates changing parameters on the logit scale, which would also solve this problem. 14.1.3 Optimizer tries very large dispersion parameters For some reason the TMB dnbinom2 function cannot handle large dispersion parameters, even though the standard R dnbinom function seems fine with them. Nevertheless, this entire issue can be avoided by setting priors on the dispersion parameters. In the future we might try to exploit the fact that the limit of the log negative binomial density as the dispersion parameter gets large tends to the log poisson density. Such an improvement is not entirely trivial due to the need for maintaining differentiability. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
